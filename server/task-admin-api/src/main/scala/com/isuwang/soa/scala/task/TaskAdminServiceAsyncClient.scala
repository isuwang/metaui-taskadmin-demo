package com.isuwang.soa.scala.task

        import com.isuwang.dapeng.core._
        import com.isuwang.org.apache.thrift._
        import com.isuwang.dapeng.remoting.BaseCommonServiceClient
        import com.isuwang.soa.scala.task.TaskAdminServiceCodec._
        import scala.concurrent.{Future, Promise}
        import java.util.function.BiConsumer

        /**
         * Autogenerated by Dapeng-Code-Generator (1.2.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated

        **/
        object TaskAdminServiceAsyncClient extends BaseCommonServiceClient("com.isuwang.soa.scala.task.service.TaskAdminService", "1.0.0"){

        override def isSoaTransactionalProcess: Boolean = {

          var isSoaTransactionalProcess = false
          
          isSoaTransactionalProcess
        }

        
            /**
            * 
            **/
            def findTasks(request:com.isuwang.soa.scala.task.domain.TTaskRequest , timeout: Long) : scala.concurrent.Future[com.isuwang.soa.scala.task.domain.TTaskResponse] = {

            initContext("findTasks");

            try {
              val _responseFuture = sendBaseAsync(findTasks_args(request), new FindTasks_argsSerializer(), new FindTasks_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[findTasks_result]]

              val promise = Promise[com.isuwang.soa.scala.task.domain.TTaskResponse]()

              _responseFuture.whenComplete(new BiConsumer[findTasks_result, Throwable]{

              override def accept(r: findTasks_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def findTaskDetailById(id:Int , timeout: Long) : scala.concurrent.Future[com.isuwang.soa.scala.task.domain.TTaskDetail] = {

            initContext("findTaskDetailById");

            try {
              val _responseFuture = sendBaseAsync(findTaskDetailById_args(id), new FindTaskDetailById_argsSerializer(), new FindTaskDetailById_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[findTaskDetailById_result]]

              val promise = Promise[com.isuwang.soa.scala.task.domain.TTaskDetail]()

              _responseFuture.whenComplete(new BiConsumer[findTaskDetailById_result, Throwable]{

              override def accept(r: findTaskDetailById_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def createTask(request:com.isuwang.soa.scala.task.domain.TCreateTaskRequest , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("createTask");

            try {
              val _responseFuture = sendBaseAsync(createTask_args(request), new CreateTask_argsSerializer(), new CreateTask_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[createTask_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[createTask_result, Throwable]{

              override def accept(r: createTask_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def updateTask(request:com.isuwang.soa.scala.task.domain.TUpdateTaskRequest , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("updateTask");

            try {
              val _responseFuture = sendBaseAsync(updateTask_args(request), new UpdateTask_argsSerializer(), new UpdateTask_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[updateTask_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[updateTask_result, Throwable]{

              override def accept(r: updateTask_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def unbindSubTask(subTaskId:Int , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("unbindSubTask");

            try {
              val _responseFuture = sendBaseAsync(unbindSubTask_args(subTaskId), new UnbindSubTask_argsSerializer(), new UnbindSubTask_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[unbindSubTask_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[unbindSubTask_result, Throwable]{

              override def accept(r: unbindSubTask_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def createTaskRemark(request:com.isuwang.soa.scala.task.domain.TSaveTaskRemark , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("createTaskRemark");

            try {
              val _responseFuture = sendBaseAsync(createTaskRemark_args(request), new CreateTaskRemark_argsSerializer(), new CreateTaskRemark_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[createTaskRemark_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[createTaskRemark_result, Throwable]{

              override def accept(r: createTaskRemark_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def updateTaskRemark(request:com.isuwang.soa.scala.task.domain.TSaveTaskRemark , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("updateTaskRemark");

            try {
              val _responseFuture = sendBaseAsync(updateTaskRemark_args(request), new UpdateTaskRemark_argsSerializer(), new UpdateTaskRemark_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[updateTaskRemark_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[updateTaskRemark_result, Throwable]{

              override def accept(r: updateTaskRemark_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def deleteTaskRemark(id:Int , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("deleteTaskRemark");

            try {
              val _responseFuture = sendBaseAsync(deleteTaskRemark_args(id), new DeleteTaskRemark_argsSerializer(), new DeleteTaskRemark_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[deleteTaskRemark_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[deleteTaskRemark_result, Throwable]{

              override def accept(r: deleteTaskRemark_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def createTaskLog(request:com.isuwang.soa.scala.task.domain.TCreateTaskLog , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("createTaskLog");

            try {
              val _responseFuture = sendBaseAsync(createTaskLog_args(request), new CreateTaskLog_argsSerializer(), new CreateTaskLog_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[createTaskLog_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[createTaskLog_result, Throwable]{

              override def accept(r: createTaskLog_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def createTaskAttachment(request:com.isuwang.soa.scala.task.domain.TCreateTaskAttachment , timeout: Long) : scala.concurrent.Future[Int] = {

            initContext("createTaskAttachment");

            try {
              val _responseFuture = sendBaseAsync(createTaskAttachment_args(request), new CreateTaskAttachment_argsSerializer(), new CreateTaskAttachment_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[createTaskAttachment_result]]

              val promise = Promise[Int]()

              _responseFuture.whenComplete(new BiConsumer[createTaskAttachment_result, Throwable]{

              override def accept(r: createTaskAttachment_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def deleteTaskAttachment(id:Int , timeout: Long) : scala.concurrent.Future[Unit] = {

            initContext("deleteTaskAttachment");

            try {
              val _responseFuture = sendBaseAsync(deleteTaskAttachment_args(id), new DeleteTaskAttachment_argsSerializer(), new DeleteTaskAttachment_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[deleteTaskAttachment_result]]

              val promise = Promise[Unit]()

              _responseFuture.whenComplete(new BiConsumer[deleteTaskAttachment_result, Throwable]{

              override def accept(r: deleteTaskAttachment_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success()
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          
            /**
            * 
            **/
            def findAllTaskNos4Picker( timeout: Long) : scala.concurrent.Future[List[com.isuwang.soa.scala.task.domain.TTaskPickerContainer]] = {

            initContext("findAllTaskNos4Picker");

            try {
              val _responseFuture = sendBaseAsync(findAllTaskNos4Picker_args(), new FindAllTaskNos4Picker_argsSerializer(), new FindAllTaskNos4Picker_resultSerializer(), timeout).asInstanceOf[java.util.concurrent.CompletableFuture[findAllTaskNos4Picker_result]]

              val promise = Promise[List[com.isuwang.soa.scala.task.domain.TTaskPickerContainer]]()

              _responseFuture.whenComplete(new BiConsumer[findAllTaskNos4Picker_result, Throwable]{

              override def accept(r: findAllTaskNos4Picker_result, e: Throwable): Unit = {
                if(e != null)
                  promise.failure(e)
                else
                  promise.success(r.success)
                }
              })
              promise.future
            }catch{
              case e: SoaException => throw e
              case e: TException => throw new SoaException(e)
            }finally {
              destoryContext()
            }
          }
          

      }
      